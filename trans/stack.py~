Class Stack:
    def __init(self, df, params):
        self.df = df


    # INTERNAL methods: take df as argument
    -------------------------------------------------------
    def residual(self, df):
        regStarts = regEnd - regWindow + timedelta(days=1)

        pct_dfs = pct_df.loc[ regStarts:regEnd,:]
        
        # Do a (non-rolling) regression on entire DataFrame
        rps = RegPipe(df)
        rps.indCols( [ idx["Pct", "SPY"] ] )
        rps.regressSingle()

        # Set up for attribution
        #  - Backward fill the betas, no rolling.  That is the beta for the single regression is applied to the entire window
        rollAmount = 0
        fillMethod = "bfill"

        rps.attrib_setup(df, rps.beta_df, rollAmount, fillMethod)

        # Perfrom the attribution
        rps.attrib()

        # Access the residuals
        residuals = rps.retAttr_df.loc[:, idx["Error",:]]

        return residuals

    # EXTERNAL methods: takes df from SELF.df
    -------------------------------------------------------

    def nextChunk(self, start, end):
        """
        Return a chunk any which way you'd like.  Do we even need start and end ?
        """
        df = self.df
        chunk = df.loc[s:e,:]
        return chunk

    def repeated(self, start , end, windowTimeDelta, stepTimeDelta):
        firstDate = self.df.index[0]
        
        oneDayTimeDelta = timedelta(days=1)

        results = []
        
        # End e (inclusive) and start s for first fit
        (e,s)  = (end, end - windowTimeDelta + oneDayTimeDelta)

        while (s >= start):
            # NOTE: s,e are DateTimes so s:e are all the rows INCLUSIVE of e (as opposed to if s,e were integers, in which case last row is (e-1)
            thisDf = self.nextChunk(start, end)

            if self.Debug:
                print("rollingFit: {s} to {e}".format(s=s, e=e))
                
            result  = self.fit(thisDf)

            results.append( (e, result) )

            e = e - stepTimeDelta
            s = e - windowTimeDelta + oneDayTimeDelta


        return results
